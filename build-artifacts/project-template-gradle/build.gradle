/*
*	Script builds apk in release or debug mode
*	To run: 
*			gradle buildapk -Prelease (release mode)
*			gradle buildapk (debug mode -> default)
* 	Options:
*			-Prelease  //this flag will run build in release mode
*			-PksPath=[path_to_keystore_file]
*			-PksPassword=[password_for_keystore_file]
*			-Palias=[alias_to_use_from_keystore_file]
*			-Ppassword=[password_for_alias]
*
*			-PtargetSdk=[target_sdk]
*			-PbuildToolsVersion=[build_tools_version]
*			-PsupportVersion=[support_version]
*			-PcompileSdk=[compile_sdk_version]

*			-PdontRunSbg=[true/false]
*/

import java.nio.file.Files
import java.nio.file.Paths
import java.util.regex.Pattern
import groovy.json.JsonSlurper

buildscript {
	repositories {
		jcenter()
	}

	dependencies {
		classpath "com.android.tools.build:gradle:2.2.3"
	}
}

apply plugin: "com.android.application"

def isWinOs = System.properties['os.name'].toLowerCase().contains('windows')
def metadataParams = new LinkedList <String> ()
def allJarPaths = new LinkedList <String> ()
def configStage = "\n:config phase: "
def buildDir = file("build")
def configurationsDir = file("build/configurations")
def dependenciesJsonPath = file("dependencies.json")
def nativescriptDependencies = new groovy.json.JsonSlurper().parseText(dependenciesJsonPath.text)
def dontRunSbg = project.hasProperty("dontRunSbg")
def asbgProject = project(":asbg")
def computeCompileSdkVersion = { -> project.hasProperty("compileSdk") ? compileSdk : 23 }
def computeTargetSdkVersion = { -> project.hasProperty("targetSdk") ? targetSdk : 23 }
def computeBuildToolsVersion = { -> project.hasProperty("buildToolsVersion") ? buildToolsVersion : "25.0.2" }

asbgProject.ext.outDir = file("src/main/java")
asbgProject.ext.jsCodeDir = file("src/main/assets/app")

project.ext.selectedBuildType = project.hasProperty("release") ? "release" : "debug"

android {
	compileSdkVersion computeCompileSdkVersion()
	buildToolsVersion computeBuildToolsVersion()

	defaultConfig {
		minSdkVersion 17
		targetSdkVersion computeTargetSdkVersion()
		ndk {
			abiFilters "armeabi-v7a", "x86"
		}
	}

	sourceSets.main {
		jniLibs.srcDir "$projectDir/libs/jni"
	}

	signingConfigs {
		release {
			if (project.hasProperty("release")) {
				if (project.hasProperty("ksPath") &&
					project.hasProperty("ksPassword") &&
					project.hasProperty("alias") &&
					project.hasProperty("password"))
				{
					storeFile file(ksPath)
					storePassword ksPassword
					keyAlias alias
					keyPassword password
				}
			}
		}
	}
	buildTypes {
		release {
			signingConfig signingConfigs.release
		}
	}

	def applyPluginIncludeGradles = { ->
		def dimensions = new ArrayList<String>()
		def includes = new ArrayList<String>()
		def flavorNumber = 0

		if (!buildDir.exists()) {
			buildDir.mkdir()
		}

		configurationsDir.delete()
		configurationsDir.mkdir()

		nativescriptDependencies.each {
			def androidDir = file("${it.directory}/platforms/android")
			if (!androidDir.exists()) return

			def packageJsonPath = file("${it.directory}/package.json")
			def packageJson = new groovy.json.JsonSlurper().parseText(packageJsonPath.text)
			def pluginName = packageJson.name
			def dimensionName = sanitizeDimensionName(pluginName)

			dimensions.add(dimensionName)
			def flavor = "F${flavorNumber++}"

			def includeGradleFile = new File(androidDir, "include.gradle")
			def destinationDir = file("build/configurations/${pluginName}/")
			destinationDir.mkdir()
			def destinationIncludeGradleFile = file("build/configurations/${pluginName}/include.gradle")
			if (includeGradleFile.exists()) {
				println "\t + add include.gradle from ${includeGradleFile}"
				destinationIncludeGradleFile.text = replaceProductFlavorInContent(includeGradleFile.text, dimensionName, flavor)
			} else {
				println "\t + creating include.gradle for plugin ${file(it.directory)}"
				destinationIncludeGradleFile.text = createProductFlavorsContent(flavor, dimensionName)
			}

			includes.add(destinationIncludeGradleFile.getAbsolutePath());
		}

		return [dimensions, includes];
	}

	def applyAppGradle = { ->
		def appGradle = file("../../app/App_Resources/Android/app.gradle");
		if (appGradle.exists()) {
			println "\t + add app.gradle from ${appGradle}"
			apply from: appGradle.getAbsolutePath()
		}
	}

	def renameResultApks = { variant ->
		def name
		variant.outputs.each { output ->
			def apkDirectory = output.packageApplication.outputFile.parentFile
			def abiName = "";
			if (output.getFilter(com.android.build.OutputFile.ABI)) {
				abiName = "-" + output.getFilter(com.android.build.OutputFile.ABI);
			}
			def apkNamePrefix = rootProject.name + "-" + variant.buildType.name + abiName
			name = apkNamePrefix + ".apk"
			output.packageApplication.outputFile = new File(apkDirectory, name);
		}
	}

	def generateMetadata = { variant ->
		def variantName = variant.name.capitalize()
		def compileSourcesTaskName = "compile${variantName}Sources"
		def compileSourcesTask = project.tasks.findByName(compileSourcesTaskName)

		def generateBuildConfigTask = variant.generateBuildConfig;
		generateBuildConfigTask.finalizedBy(collectAllJars)
		if (!dontRunSbg) {
			collectAllJars.finalizedBy(setProperties)
		}

		compileSourcesTask.finalizedBy(buildMetadata)
	}

	println "$configStage apply from"

	def (dimensions, includes) = applyPluginIncludeGradles()
	flavorDimensions(*dimensions)
	includes.each { apply from: it }

	applyAppGradle()

	applicationVariants.all renameResultApks
	applicationVariants.all generateMetadata
}

repositories {
	jcenter()

	def pluginDependencies = nativescriptDependencies.collect { "${it.directory}/platforms/android" }
	pluginDependencies.add("libs/runtime-libs")

	flatDir {
		dirs pluginDependencies
	}
}

dependencies {
	println "$configStage dependencies"

	def addNativeScriptRuntime = { ->
		def dependencies = new ArrayList();
		def useV8Symbols = nativescriptDependencies.any {
			def packageJsonPath = file("${it.directory}/package.json");
			def packageJson = new groovy.json.JsonSlurper().parseText(packageJsonPath.text);
			return packageJson.nativescript.useV8Symbols;
		}

		def runtime = useV8Symbols ? "nativescript-regular" : "nativescript-optimized";
		println "\t + adding runtime: $runtime"
		project.dependencies.add("compile", [name: runtime, ext: "aar"])
	}

	def addDependenciesFromNativeScriptPlugins = { ->
		nativescriptDependencies.each() { dep ->
			def pluginDepsDir = file("${dep.directory}/platforms/android");
			if (!pluginDepsDir.exists()) return;
			fileTree(dir: pluginDepsDir, include: ["**/*.aar", "**/*.jar"]).each { file ->
				def length = file.name.length()
				def name = file.name.substring(0, length - 4)
				def ext = file.name.substring(length - 3)
				println "\t + adding ${ext} ${name}: ${file}"
				project.dependencies.add("compile", [name: name, ext: ext])
			}
		}
	}

	def suppotVer = "22.2.0";
	if (project.hasProperty("supportVersion")) {
		suppotVer = supportVersion
	}
	
	compile "com.android.support:support-v4:$suppotVer"
	compile "com.android.support:appcompat-v7:$suppotVer"
	debugCompile "com.android.support:design:$suppotVer"

	compile fileTree(dir: "$projectDir/libs", include: ["**/*.jar"])

	addNativeScriptRuntime()
	addDependenciesFromNativeScriptPlugins()

	// TODO: Merge plugins android manifests, interpolate manifests and include.gradles??
	// This is what the flavors are for. An F0, F1, F2 etc. flavors will be created for each plugin
	// and the plugin's resources will be copied to src/F0, src/F1 etc. then building F0F1F2debug will include
	// The F0 F1 F2 folders, the debug folder and the main folder form src.
	// Test it works, check if the flavor src can be set to node_modules directly so it does not require CLI to copy stuff.
}

def updateProductFlavorsContent(flavor, dimensionName, oldContent) {
	def endIndex = oldContent.length() - 1;
		def index = 0;
		def newContent = "";
		def level = -1;
		def dimensionFound = false;

		while (index <= endIndex) {
			if (level == 0 && (oldContent[index] == '"' || oldContent[index] == "'")) {
				def closingQuotes = oldContent.indexOf('"', index + 1);
				if (closingQuotes == -1) {
					closingQuotes = oldContent.indexOf("'", index + 1);
				}

				index = closingQuotes + 1;
				newContent += "\"${flavor}\"";
				continue;
			}

			if (oldContent[index] == "{") {
				level++;	
			}

			if (oldContent[index] == "}") {
				level--;
			}

			if (level > 0) {
				if (!dimensionFound && oldContent.indexOf("dimension", index) == index) {
					newContent += "dimension \"${dimensionName}\"";
					dimensionFound = true;
					index += "dimension ".length();
					def openingQuoutes = oldContent.indexOf('"', index);
					if (openingQuoutes == -1) {
						openingQuoutes = oldContent.indexOf("'", index);
					}

					def closingQuotes = oldContent.indexOf('"', openingQuoutes + 1);
					if (closingQuotes == -1) {
						closingQuotes = oldContent.indexOf("'", openingQuoutes + 1);
					}	

					index = closingQuotes + 1;
				}
			}

			newContent += oldContent[index];

			index++;
		}

		return newContent;
}

def createProductFlavorsContent(flavor, dimensionName, includeAndroidContent = true) {
	if (includeAndroidContent) {
		return """
android {
	productFlavors {
		"${flavor}" {
			dimension "${dimensionName}"
		}
	}
}
"""
		return content;
	} else {
		return """
	productFlavors {
		"${flavor}" {
			dimension "${dimensionName}"
		}
	}
"""
	}
}

def sanitizeDimensionName(str) {
	return str.replaceAll(/\W/, "")
}

def replaceProductFlavorInContent(content, dimension, flavor) {
	def indexStart = content.indexOf("productFlavors");
	def index = indexStart  + "productFlavors".length();
	def indexEnd = -1;
	def nestedOpenBraketsCount = 0;

	if (indexStart != -1) {
		while (index < content.length())
		{
			// print content[index];
			if (content[index] == "}")
			{
				nestedOpenBraketsCount--;

				if (nestedOpenBraketsCount == 0)
				{
					indexEnd = index;
					break;
				}
			}
			else if (content[index] == "{")
			{
				nestedOpenBraketsCount++;
			}

			index++;
		}
	}

	if (indexEnd != -1)
    {
      // full content of productFlavors { ... } -> the substring is parenthesis to parenthesis -> { ... }
      def oldProductFlavorsText = content.substring(indexStart, indexEnd + 1);

      def newProductFlavorsContent = updateProductFlavorsContent(flavor, dimension, oldProductFlavorsText);
      
      return content.replace(oldProductFlavorsText, newProductFlavorsContent);
    }
    else
    {
        def androidContentExists = content.indexOf("android {") != -1;
        def newProductFlavorsContent = createProductFlavorsContent(flavor, dimension, !androidContentExists);
        
        if (androidContentExists)
        {
           return content.replace("android {", "android { ${newProductFlavorsContent}");
        }
        else
        {
           return "${newProductFlavorsContent} \t ${content}"
        }
    }
}

task cleanLocalAarFiles(type: Delete) {
	delete fileTree(dir: "$projectDir/libs/aar", include: ["*.aar"])
}

task ensureMetadataOutDir {
	def outputDir = file("$projectDir/metadata/output/assets/metadata")
	outputDir.mkdirs()
}

task collectAllJars {
	description "gathers all paths to jar dependencies before building metadata with them"
	
	def explodedAarDir = project.buildDir.getAbsolutePath() + "/intermediates/exploded-aar/"
	def sdkPath = android.sdkDirectory.getAbsolutePath();
	def androidJar = sdkPath + "/platforms/" + android.compileSdkVersion + "/android.jar"
	
	doFirst {
		configurations.compile.each { File dependencyFile ->
			// println "\t+" + dependencyFile.getAbsolutePath()
			allJarPaths.add(dependencyFile.getAbsolutePath())
		}
		
		allJarPaths.add(androidJar);
		
		def ft = fileTree(dir: explodedAarDir, include: "**/*.jar")
		ft.each { currentJarFile ->
			allJarPaths.add(currentJarFile.getAbsolutePath())
		}

		metadataParams.add("metadata-generator.jar");
		metadataParams.add("$projectDir/metadata/output/assets/metadata");
		def jars = new LinkedList<File>()
		for(def i = 0; i < allJarPaths.size(); i++) {
			metadataParams.add(allJarPaths.get(i));
			def f = new File(allJarPaths.get(i))
			if (f.getName().endsWith(".jar")) {
				jars.add(f)
			}
		}
		
		asbgProject.ext.jarFiles = jars
	}
}

task buildMetadata (type: JavaExec) {
	description "builds metadata with provided jar dependencies"
	
	inputs.files(allJarPaths)
	inputs.dir("$buildDir/intermediates/classes")

	outputs.files("metadata/output/assets/metadata/treeNodeStream.dat", "metadata/output/assets/metadata/treeStringsStream.dat", "metadata/output/assets/metadata/treeValueStream.dat")

	doFirst {
		// get compiled classes to pass to metadata generator		
		// these need to be called after the classes have compiled		
		def classesDir = "$buildDir/intermediates/classes"		

		def classesSubDirs = new File(classesDir).listFiles()
		def selectedBuildType = project.ext.selectedBuildType

		for (File subDir: classesSubDirs) {
			if (!subDir.getName().equals(selectedBuildType)) {
				def subDirBuildType = new File(subDir, selectedBuildType)
				if (subDirBuildType.exists()) {
					metadataParams.add(subDirBuildType.getAbsolutePath());
				}
			}
		}

		def classesDirBuildType = new File(classesDir, selectedBuildType)
		if (classesDirBuildType.exists()) {
			metadataParams.add(classesDirBuildType.getAbsolutePath())
		}

		workingDir "build-tools"
		main "-jar"
		args metadataParams.toArray()
	}
	
	doLast {
		copy {
			from "$projectDir/metadata/output/assets/metadata"
			into "$projectDir/src/main/assets/metadata"
		}
	}
}

task generateTypescriptDefinitions (type: JavaExec) {
	def paramz = new ArrayList<String>();
	def includeDirs = ["com.android.support", "/platforms/" + android.compileSdkVersion]

	doFirst {
		delete "build-tools/typings"

		workingDir "build-tools"

		main "-jar"

		paramz.add("dts-generator.jar");
		paramz.add("-input");

		for (String jarPath: project.jarFiles) {
			// don't generate typings for runtime jars and classes
			if (shouldIncludeDirForTypings(jarPath)) {
				paramz.add(jarPath);
			}
		}

		paramz.add("-output");
		paramz.add("typings");

		args paramz.toArray();
	}

	def shouldIncludeDirForTypings = { path ->
		for (String p: includeDirs) {
			if (path.indexOf(p) > -1) {
				return true;
			}
		}

		return false;
	}
}
generateTypescriptDefinitions.onlyIf {
	project.hasProperty("generateTypings") && Boolean.parseBoolean(project.generateTypings)
}

task copyTypings {
	doLast {
		println "Copied generated typings to application root level. Make sure to import android.d.ts in reference.d.ts"
		copy {
			from "$projectDir/build-tools/typings"
			into "$projectDir/../../"
		}
	}
}
generateTypescriptDefinitions.finalizedBy copyTypings
copyTypings.onlyIf { generateTypescriptDefinitions.didWork }

task setProperties {
	project.ext.jarFiles = []
	doLast {
		def list = [];
		allJarPaths.each({f -> 
			if (f.endsWith(".jar")) {
				list.add(f);
			}
		})
		project.jarFiles = list;
	}
} 
setProperties.finalizedBy("asbg:generateBindings", generateTypescriptDefinitions)

ensureMetadataOutDir.dependsOn cleanLocalAarFiles
collectAllJars.dependsOn ensureMetadataOutDir
buildMetadata.dependsOn collectAllJars

task buildapk {
	if (project.hasProperty("release")) {
		dependsOn "assembleRelease"
	}
	else {
		dependsOn "assembleDebug"
	}
}

task cleanMetadata (type: Delete) {
	delete "$projectDir/metadata/output"
}
clean.dependsOn(cleanMetadata)

task cleanFlavors (type: Delete) {
	doLast {
		def srcDir = new File("$projectDir/src")
		srcDir.listFiles().each({ f ->
			if (!f.getName().equals("main") &&
				!f.getName().equals("debug") &&
				!f.getName().equals("release"))	{
				delete f
			}
		})
	}
}
clean.dependsOn(cleanFlavors)

task cleanBindings(type: Delete) {
	delete "$projectDir/src/main/java/com/tns/gen"
}
clean.dependsOn(cleanBindings)

clean.dependsOn(":asbg:clean")